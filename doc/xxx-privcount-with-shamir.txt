

0. Acknowledgments

  Tariq Elahi, George Danezis, and Ian Goldberg designed and implemented
  the PrivEx blinding scheme. Rob Jansen and Aaron Johnson extended
  PrivEx's differential privacy guarantees to multiple counters in
  PrivCount:

  https://github.com/privcount/privcount/blob/master/README.markdown#research-background

  Rob Jansen and Tim Wilson-Brown wrote the majority of the experimental
  PrivCount code, based on the PrivEx secret-sharing variant. This
  implementation includes contributions from the PrivEx authors, and
  others:

  https://github.com/privcount/privcount/blob/master/CONTRIBUTORS.markdown

  This research was supported in part by NSF grants CNS-1111539,
  CNS-1314637, CNS-1526306, CNS-1619454, and CNS-1640548.

  The use of a Shamir secret-sharing-based approach is due to a
  suggestion by Aaron Johnson (iirc); Carolin ZÃ¶belein did some helpful
  analysis here.

1. Introduction and scope

  PrivCount is a privacy-preserving way to collect aggregate statistics
  about the Tor network without exposing the statistics from any single
  Tor relay.

  This document describes the behavior of the in-Tor portion of the
  PrivCount system.  It DOES NOT describe the counter configurations,
  or any other parts of the system. (These will be covered in separate
  proposals.)

2. PrivCount overview

  Here follows an oversimplified summary of PrivCount, with enough
  information to explain the Tor side of things.  The actual operation
  of the non-Tor components is trickier than described below.

  In PrivCount, a Data Collector (in this case a Tor relay) shares
  numeric data with N different Tally Reporters. (A Tally Reporter
  performs the summing and unblinding roles of the Tally Server and Share
  Keeper from experimental PrivCount.)

  All N Tally Reporters together can reconstruct the original data, but
  no (N-1)-sized subset of the Tally Reporters can learn anything about
  the data.

  (In reality, the Tally Reporters don't reconstruct the original data
  at all! Instead, they will reconstruct a _sum_ of the original data
  across all participating relays.)

  In brief, the system works as follow:

  To share data, for each counter value V to be shared, the relay first adds
  Gaussian noise to V in order to produce V', uses Shamir
  secret-sharing to generate K shares of V' (K<=N), and encrypts each
  share to a different tally reporter.  Each tally reporters adds all of
  the shares that it received for each counter, and publishes the total
  share.  The tally reporters then, collectively, perform secret
  reconstruction, and learn the sum of all the different V values.

  In order to prevent bogus data from corrupting the tally, the Tally
  Reporters can perform this algorithm several times, with different
  subsets of the data.  The use of Shamir secret sharing lets us
  survive up to N-K crashing TRs.

  Below we describe the algorithm in more detail, and describe the data
  format to use.

3. The algorithm

  All values below are B-bit integers modulo some prime P; we suggest
  B=64 and P = 2**64 - 257 (hex fffffffffffffeff).  The size of this
  field is an upper limit on the largest sum we can calculate; it is not
  a security parameter.

  There are N tally reporters: every participating relay must agree on
  which N exist, and on their current public keys.  We suggest listing
  them in the consensus networkstatus document.  All parties must also
  agree on some ordering the tally reporters.  Similarly, all parties
  must also agree on some value K<N.

  There are a number of well-known "counters", identified known by ASCII
  identifiers.  Each counter is a value that the participating relays
  will know how to count.  Let C be the number of counters.

3.1. Data collection side

  At the start of each period, every data collector ("client" below)
  initializes their state as follows

      1. For every tally reporter with index i, the client constructs a
         random 32-byte random value SEED_i.  The client then generates
         a pseudorandom bitstream of C*B bits using the SHAKE-256
         XOF with SEED_i as its input, and divides this stream into
         C values, with the c'th value denoted by MASK(i, c).

         [Because P is very close to a power of 2, nearly all seeds will
         produce MASK values in range 0...(P-1).  If any does not, the
         client picks a new seed.]

      2. The client encrypts SEED_i using the public key of Tally
         Reporter i, and remembers this encrypted value.  It discards
         SEED_i.

      3. For every counter j, the client generates a noise value Z_j
         from an appropriate gaussian distribution. If the noise value is
         negative, the client adds P to bring Z_j into the range 0...(P-1).
         (Adding the noise first implements the safe "snapping" procedure
         from Appendix C. This is a security-sensitive operation.)
         The client then uses Shamir
         secret sharing to generate N shares (x,y) of Z_j, 1 <= x <= N,
         with the x'th share to be used by the x'th Tally Reporter.  See
         Appendix A for more on Shamir secret sharing.  See Appendix B
         for another idea about X coordinates.

         The client picks a random value CTR_j.

         The client then subtracts (MASK(x, c)+CTR) from y, giving
         "encrypted shares" of (x, y0) where y0 = y-MASK(x,c)-CTR.

         The client then discards all MASK values, and all original
         shares (x,y), and the noise value Z_j. For each counter j, it
         remembers CTR_j, and N shares of the form (x, y0).

  To increment a counter by some value "inc":

      1. The client adds "inc" to the CTR_j value for that counter,
         modulo P.

         (This step is chosen to be optimal, since it will happen more
         frequently than any other step in the computation.)

  To publish the counter values:

      1. The client publishes, in the format described below:

         The list of counters it knows about
         The list of TRs it knows about
         For each TR, encrypted to that TR's public key:
            For each counter j:
                A list of (x, CTR_j + y0), for the share (x,y0)
                corresponding to CTR_j and the TR.
            SEED_i as encrypted earlier to TR's public key.

3.2. TR side

  This section is less completely specified than the data collector's
  behavior: I expect that the TRs will be easier to update as we procede.

  (Each TR has a long-term identity key (ed25519).  It also has a
  sequence of short-term curve25519 keys, each associated with a single
  round of data collection.)

   1. When a group or TRs receives information from the data collectors,
      they collectively chose a set of DCs and a set of counters such
      that every TR in the group has a valid entry for every counter,
      from every DC in the set.

      To be valid, an entry must not only be well-formed, but must also
      have the x coordinate in its shares corresponding to the
      TR's position in the list of TRs.

   2. For each data collector's report, each TR decrypts its part of the
      client's report using its curve25519 key.  It uses SEED_i and
      SHAKE-256 to regenerate MASK(0) through MASK(C-1).  Then for each
      share (x, CTR_j + y0), the TR reconstructs the true share for that
      (client,counter) pair as (x, y_final), where
      y_final = CTR_j + y0 + MASK(j)).

   3. For every counter in the set, each TR computes the sum of the
      y_final values from all clients.

   4. For every counter in the set, each TR publishes its a share of
      the sum as (x, SUM(y_final)).

   5. If at least K TRs publish correctly, then the sum can be
      reconstructed using lagrange polynomial interpolation. (See
      Appendix A).

   6. If the reconstructed sum is greater than P/2, it is probably a negative
      value. The value can be obtained by subtracting P from the sum.
      (Negative values are generated when negative noise is added to small
      signals.)

4. The document format

4.1. The counters document.

  This document format builds on the line-based directory format used
  for other tor documents, described in Tor's dir-spec.txt.

  Using this format, we describe a "counters" document that publishes
  the shares collected by a given DC, for a single TR.

  The "counters" document has these elements:

    "privctr-dump-format" SP VERSION SP SigningKey

       [At start, exactly once]

       Describes the version of the dump format, and provides an ed25519
       signing key to identify the relay. The signing key is encoded in
       base64 with padding stripped. VERSION is "alpha" now, but should
       be "1" once this document is finalized.

    "starting-at" SP IsoTime

       [Exactly once]

       The start of the time period when the statistics here were
       collected.

    "ending-at" SP IsoTime

       [Exactly once]

       The end of the time period when the statistics here were
       collected.

    "share-parameters" SP Number SP Number

       [Exactly once]

       The number of shares needed to reconstruct the client's
       measurements (K), and the number of shares produced (N),
       respectively.

    "tally-reporter" SP Identifier SP Integer SP Key

       [At least twice]

       The curve25519 public key of each Tally Reporter that the relay
       believes in.  (If the list does not match the list of
       participating tally reporters, they won't be able to find the
       relay's values correctly.)  The identifiers are non-space,
       non-nul character sequences.  The Key values are encoded in
       base64 with padding stripped; they must be unique within each
       counters document.  The Integer values are the X coordinate of
       the shares associated with each tally-reporter.

    "encrypted-to-key" SP Key

       [Exactly once]

       The curve25519 public key to which the report below is encrypted.
       Note that it must match one of the tally-reporter options above.


    "report" NL
      "----- BEGIN ENCRYPTED MESSAGE-----" NL
      Base64Data
      "----- END ENCRYPTED MESSAGE-----" NL

      [Exactly once]

      An encrypted document, encoded in base64. The plaintext format is
      described in section 4.2. below. The encryption is as specified in
      section 5 below, with STRING_CONSTANT set to "privctr-shares-v1".

    "signature" SP Signature

       [At end, exactly once]

       The Ed25519 signature of all the fields in the document, from the
       first byte, up to but not including the "signature" keyword here.
       The signature is encoded in base64 with padding stripped.

4.2. The encrypted "shares" document.

  The shares document is send, encrypted, in the "report" element above.
  Its plaintext contents include these fields:

   "encrypted-seed" NL
      "----- BEGIN ENCRYPTED MESSAGE-----" NL
      Base64Data
      "----- END ENCRYPTED MESSAGE-----" NL

      [At start, exactly once.]

      An encrypted document, encoded in base64. The plaintext value is
      the 32-byte value SEED_i for this TR. The encryption is as
      specified in section 5 below, with STRING_CONSTANT set to
      "privctr-seed-v1".

   "d" SP Keyword SP Integer

      [Any number of times]

      For each counter, the name of the counter, and the obfuscated Y
      coordinate of this TR's share for that counter.  (The Y coordinate
      is calculated as CTR_j+y0 as in 3.1 above.)  The order of counters
      must correspond to the order used when generating the MASK() values;
      different clients do not need to choose the same order.

5. Hybrid encryption

   This scheme is taken from rend-spec-v3.txt, section 2.5.3, replacing
   "secret_input" and "STRING_CONSTANT".  It is a hybrid encryption
   method for encrypting a message to a curve25519 public key PK.

     We generate a new curve25519 keypair (sk,pk).

     We run the algorithm of rend-spec-v3.txt 2.5.3, replacing
     "secret_input" with Curve25519(sk,PK) | salt | SigningKey, where
     SigningKey is the DC's signing key.  (Including the DC's SigningKey
     here prevents one DC from replaying another one's data.)

     We transmit the encrypted data as in rend-spec-v3.txt 2.5.3,
     prepending pk.


Appendix A. Shamir secret sharing for the impatient

   In Shamir secret sharing, you want to split a value in a finite
   field into N shares, such that any K of the N shares can
   reconstruct the original value, but K-1 shares give you no
   information at all.

   The key insight here is that you can reconstruct an K+1-degree
   polynomial given K distinct points on its curve, but not given
   K-1 points.

   So, to split a secret, we going to generate a (K-1)-degree
   polynomial.  We'll make the Y intercept of the polynomial be our
   secret, and choose all the other coefficients at random from our
   field.

   Then we compute the (x,y) coordinates for x in [1, N].  Now we
   have N points, any K of which can be used to find the original
   polynomial.

   Moreover, we can do what privcount wants here, because adding the
   y coordinates of N shares gives us shares of the sum:  If P1 is
   the polynomial made to share secret A and P2 is the polynomial
   made to share secret B, and if (x,y1) is on P1 and (x,y2) is on
   P2, then (x,y1+y2) will be on P1+P2 ... and moreover, the y
   intercept of P1+P2 will be A+B.

   To reconstruct a secret from a set of shares, you have to either
   go learn about Lagrange polynomials, or just blindly copy a
   formula from your favorite source.

   Here is such a formula, as pseudocode^Wpython, assuming that
   each share is an object with a _x field and a _y field.

     def interpolate(shares):
        for sh in shares:
           product_num = FE(1)
           product_denom = FE(1)
           for sh2 in shares:
               if sh2 is sh:
                   continue
               product_num *= sh2._x
               product_denom *= (sh2._x - sh._x)

           accumulator += (sh._y * product_num) / product_denom

       return accumulator


Appendix B. An alternative way to pick X coordinates

   Above we describe a system where everybody knows the same TRs and
   puts them in the same order, and then does shamir secret sharing
   using "x" as the x coordinate for the x'th TR.

   But what if we remove that requirement by having x be based on a hash
   of the public key of the TR?  Everything would still work, so long as
   all users chose the same K value.  It would also let us migrate TR
   sets a little more gracefully.


Appendix C. Safely adding floating-point noise to counters using "snapping"

   When we add noise to a counter value (signal), we want the added noise to
   protect all of the bits in the signal, to ensure differential privacy.

   Because noise values are generated from random double(s) using
   floating-point calculations, the resulting low bits are not distributed
   evenly enough to ensure differential privacy.

   To create differentially private noised signal, we need to implement
   a "snapping" mechanisism. As described by Ilya Mironov, it is:
     1. Generate a floating-point noise value at random.
     2. Collect the floating-point signal value.
     3. Add the floating-point signal to the floating-point noise.
     4. Round the noised signal to remove the lower bits.
        (These bits of the signal are not protected, because the corresponding
        bits in the noise are poorly distributed.)
     5. Report the rounded noised signal as a differentially private value.

   We implement a variant of this procedure, which produces an outcome that is
   not numerically equivalent, but is just as safe:
     1. Generate a floating-point noise value at random.
    *2. Truncate the noise to remove the fractional bits.
        (These bits can never correspond to signal bits, because PrivCount only
        collects integer counters.)
    *3. Initialise the integer counter value with the integer noise value.
    *4. Encrypt the counter using a homomorphic scheme.
    *5. As events arrive, increment the integer counter.
    *6. Send the encrypted counter with partial noise to the Tally Reporters,
        which then reassemble a noised sum from all Data Collectors.
    *7. At the end of a collection, report the counter as a differentially
        private value.

   This procedure is security-sensitive: changing the order of additions
   and truncations can expose the low bits of the signal or noise.

   This analysis is based on section 5.2 of:
   "On Significance of the Least Significant Bits For Differential Privacy"
   Ilya Mironov, ACM CCS 2012
   https://www.microsoft.com/en-us/research/wp-content/uploads/2012/10/lsbs.pdf

   Although this analysis applies to laplacian noise, we assume a similar
   analysis applies to guassian noise. (If we add laplacian noise on DCs,
   the total ends up with a gaussian distribution anyway.)

   Alternately, we could use a pure-integer transform to create gaussian
   noise, and avoid floating-point issues entirely. But it is unclear whether a
   pure-integer gaussian or laplacian noise transform exists, or if such
   a transform would suffer from any (similar or different) drawbacks when
   used for differential privacy.

   This analysis also assumes that a clamp() function is available to
   clamp large signal and noise values to an infinite floating-point value.
   Instead of clamping, PrivCount's arithmetic wraps modulo P. We believe that
   this is safe, because any reported values this large will be meaningless
   modulo P, because it is a simple transform of a noised signal value.


Appendix D. Scaling and binning

   Floating-point precision limits sometime require us to scale the noise
   value by a scaling factor, which is called the "sensitivity" in the context
   of differential privacy. The sensitivity is an upper bound on the
   resolution of the signal. (That is, all multiples of the signal must be
   possible input values. Intermediate values are also permitted.)

   To protect the low bits of signals that are added to scaled noise, we also
   need to "bin" these signals into multiples of the sensitivity.

   In Mironov's paper, scaled snapping works as follows:
   (The prodecure in Appendix C assumes a sensitivity of 1.)
     1. Generate a floating-point noise value at random.
    *2. Multiply the floating-point noise by the floating-point sensitivity.
     3. Collect the floating-point signal value.
     4. Add the floating-point signal to the floating-point noise.
    *5. Round the noised signal to the nearest multiple of the sensitivity,
        to remove the lower bits. (These bits of the signal are not protected,
        because the corresponding bits in the noise are poorly distributed.)
    *6. Report the rounded noised signal as a differentially private value.

   Therefore, we modify the procedure in Appendix C as follows, to produce an
   outcome that is not numerically equivalent, but is just as safe:
     1. Generate a floating-point noise value at random.
     2. Multiply the floating-point noise by the floating-point sensitivity.
    *3. Truncate the scaled noise to remove the fractional bits.
        (These bits can never correspond to signal bits, because PrivCount only
        collects integer counters.)
     4. Initialise the integer counter value with the integer noise value.
     5. Encrypt the counter using a homomorphic scheme.
    *6. Add a random integer value in -sensitivity/2...sensitivity/2. This
        destroys the low bits in the signal and noise. It does not introduce
        bias, and only introduces minimal additional noise. (This is equivalent
        to rounding the encrypted value to the nearest multiple of the signal,
        as long as the MASK() value is a uniformly distributed random value.)
     7. As events arrive, increment the integer counter.
     8. Send the encrypted counter with partial noise to the Tally Reporters,
        which then reassemble a noised sum from all Data Collectors.
    *9. Round the sum to the nearest multiple of the sensitivity, as the
        remaining precision is meaningless.
   *10. At the end of a collection, report the rounded sum as a differentially
        private value.

   This procedure is security-sensitive: changing the order of additions,
   multiplications, truncations, or rounding can expose the low or high bits
   of the signal, noise, or MASK() value.

   This analysis is based on section 5.2 of:
   "On Significance of the Least Significant Bits For Differential Privacy"
   Ilya Mironov, ACM CCS 2012
   https://www.microsoft.com/en-us/research/wp-content/uploads/2012/10/lsbs.pdf


Appendix Z. Remaining client-side uncertainties

   [These are the uncertainties at the client side. I'm not considering
    TR-only operations here unless they affect clients.]

   Should we do a multi-level thing for the signing keys?  That is, have
   an identity key for each TR and each DC, and use those to sign
   short-term keys?

   How to tell the DCs the parameters of the system, including:
      - who the TRs are, and what their keys are?
      - what the counters are, and how much noise to add to each?
      - how do we impose a delay when the noise parameters change?
        (this delay ensures differential privacy even when the old and new
        counters are compared)
        - or should we try to monotonically increase counter noise?
      - when the collection intervals start and end?
      - what happens in networks where some relays report some counters, and
        other relays report other counters?
        - do we just pick the latest counter version, as long as enough relays
          support it?
          (it's not safe to report multiple copies of counters)

   How the TRs agree on which DCs' counters to collect?

   How data is uploaded to DCs?

   What to say about persistence on the DC side?


